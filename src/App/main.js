//РАБОТА С ЧИСЛАМИ
let number1 = 81; //обьявляем переменную намбер
console.log(number1);//выводим в консоль f12
//1.получение возможности безконечности
console.log(number1 / 0);//получаем ответ бесконечности(Infinity)
//значение могут быть + и - бесконечность
//2.Значение NAN когда производим какоето действие,которое в итоге не может дать число NAN - это not number
console.log("строка" * number1);//мы строку умножаем на число получим NAN
//3.возможно любые математические операции /,+,- и т.д
console.log(number1 * 4);//отввет 3*4=12
//Можно возпользоваться доступом Math.sqrt() которая позволяет использовать математичексие вычесления,
//которые более сложные чем вычитания и сложения
console.log(Math.sqrt(number1));//ответ 81/number=9 корень из числа 81
//Округления чисел
let number2 = 3.1;
console.log(Math.floor(number2));//округляет вниз
console.log(Math.ceil(number2));//округляет вверх
console.log(Math.round(number2));//округляет до ближайшего целого

//РАБОТА СО СТРОКАМ
let string = "Моя строка"; //обьявляем переменную с типом строка
//методы переменной
//с помощью метода length узнать длинну строки
console.log(string.length);
//получить доступ к символам используя вызов charAt()
console.log(string.charAt(2));// отсчет с 0 будет буква я
// если большая строка и нам надо,что бы была написана большими буквами либо маленькими
//есть специальный метод toUpperCase-,toLowerCase
console.log(string.toUpperCase());//вся строка большими буквами
console.log(string.toLowerCase());//вся строка маленькмими буквами
//взятие подстроки методы
console.log(string.substring(0, 2));//можем передать два параметра star/end он вернет подстраку
//он вернет нам строку начиная с позиции start не включая позицию end---берет с 0 до 1
console.log(string.substr(0, 4));//1 аргумент откуда начинаем обрезать нашу строку,2 аргумент -это количество симвалов
//с нулевого вырезали один симвал
console.log(string.slice(-2)); //он идентичен методу substring разница в нем, когда используем отрецательное значение(аргументы)
//если мы укажем -2 начнется отсчет с конца строки покажет ка -с конца взяли два элемента
//нам методы вернули одинаковые буквы


//РАБОТА С МАССИВАМИ
let array = [1, 2, 3, 4]; //обьявим нашу переменную и укажем значение
//обращаемся к массивам
console.log(array[1]);//выведим наш массив и видим у нас в массиве 4 элемента
//при разварачивании мы видим index этих элементов 0,1,2,3,4 и значение длинна 4
//index отсчет начинаеться с 0, если мы обратимся к 1 элементу, то выведится 2 а не 1

//заменять элементы массива
//array[1]="привет";//таким образом указали, что первый элемент массива array будет равен строке "привет"
console.log(array);//выведим наш массив видим что заменили 1 элемен --- 1:"привет"

//у массивов есть несколько свойст length-длина массива
console.log(array.length);//видим длинна 4
//если у нас в массиве большое количество элементов мы неможеи сосчетать, нам нужно узнать последний элемент
//используем следующую запись
console.log(array[array.length - 1]);
//так как массив начинаеться с 0, то последний элемент массива всегда будет равен длине массива -1


//добовление элемента в массив и удаление элемента
array.push("123");
console.log(array);//после метода push мы добавили элемент в конец массива

array.pop();
console.log(array);//метод pop мы удалили элемент с конца массива

array.unshift({
    title: "123"
});
console.log(array);//метод unshift он добавил элемент в начало массива ---первым элементом передан обьект

array.shift();
console.log(array);//метод shift удалили элемент в начале массива

//мы можем в массив передать не только цифры но и строки,обьект

// у массива есть несколько методов, которые помогают пройтись по данному массиву и произвести действия над элементами массива
console.log(array.join(" привет "));//МЕТОД join- превращает наш массив в строку
//мы можем поставить пробел, сдесь мы передаем ту часть которая у нас будет находиться между элементами массива
//между каждым элементом массива добавлено  слово привет с пробеломи между ними

//строку превратить в массив
let strings = 'Имя1,Имя2,Имя3,Имя4';
//В таком случаии используем МЕТОД split()
console.log(strings.split(','));//сдесь мы передаем ту часть,которую мы будем разбивать нашу строку в данном случаи это запятая
// у нас получился массив (4):['Имя1', 'Имя2', 'Имя3', 'Имя4']

//МЕТОД splice - это универсальный метод в работе с массивами с помощью него мы можем
//удалять элементы ,добовлять элементы,заменять элементы в массиве
console.log(array.splice());//сдесь есть несколько аргументов
console.log(array.splice(0, 2));//1 это index-0 с первого элемента массива, далее укажем количество удаляемых элементов
// этот метод вырезал часть массива он вырезал 1 и 2 - т.есть два элемента
// в массиве array
console.log(array);//у нас остались элемнты 3,4 -этот метод изменил изначальный массив
//сюда можно передать еще один аргумент,который будет вставляться вместо вырезаных элементов
console.log(array.splice(0, 2, "Вставленная строка"));

//МЕТОД slice - он копирует участок массива от начала до конца не включая конечный исходный массив, не меняеться
let array2 = [1, 2, 3, 4]
console.log(array2.slice(0, 3));//необходимо скопировать от первого элемента до третьего не включая его ответ 1,2,3
console.log(array2);//если выведим наш массив,то мы увидим исхлдный не изменился
// ---это отличие между методом slice от splice

//МЕТОД sort- он сортирует массив
let array3 = [33, 15, 25, 85, 1];
console.log(array3.sort());//сортировка произошла по образованию элементов
// в строке сдесь указано первым сиволам идет 1 потому как меньше чем 3 (5)[1, 15, 25, 33, 85]

//МЕТОД reverse()- это метод поворачивает исходный массив в обратном порядке наш массив перевернется
console.log(array3.reverse());//(5)[85, 33, 25, 15, 1]

//склеить несколько массивов у нас есть массив 2 и 3 нам необходимо к первому массиву добавить второй
console.log(array2.concat(array3));//на выходе получили новый массив
// состоящий из 2 и 3 массива добавленного (9)[1, 2, 3, 4, 85, 33, 25, 15, 1]

//МЕТОД forEach- c помощью данного метода мы можем перебрать все элементы массива
//то есть получить к ним доступ
array3.forEach(function (item, i, arr) {


//сдесь мы передаем функцию в нее мы можем передать несколько аргументов
//item-текущий массива,далее аргумент i-индекс, последний аргумент arr - текущий аррей по которому мы работаем
//назвать аргументы можем,как угодно (стандартные наименование это эти три )
    console.log(i + ':' + item + "массив: " + arr);//выведим сперва порядковый номер далее добавим двое точее, потом item потом "массив" пробел плюс arr
    console.log(item);// соотвественно все аргументы передовать не обязательно, если нужно вывести только значения item
    // все значения массива: 85,33,25,15,1

});
//мы передали первым аргументом index: 0.1.2.3
//далее у нас зачение [33,15,25,85,1];
//далее слова которое указали и все содержимое массива
//0:85массив: 85,33,25,15,1
//  1:33массив: 85,33,25,15,1
//  2:25массив: 85,33,25,15,1
//  3:15массив: 85,33,25,15,1
//  4:1массив: 85,33,25,15,1

//ЦИКЛЫ
//циклы используються для того,чтобы сделать одно и тоже действие несколько раз
//используються для того,чтобы пройтись по массиву и вывести все его элементы
// либо произвести какое либо действие  с каждым из  элементов

//ЦИКЛ for
let NewTask = [55, 25, 505, 3];
// мы делали при помощи forEach, а теперь при помощи for
//синтаксис цикла for
//С перва мы обьявляем переменную let i = 0;- первоначальный индекс 0
//далее указываем условие выхода из цикла i < array.length;
//далее до того момента пока i меньше длинны массива наша 4
//после каждой инетрации i  с помощью записи  i++ увеличиваем на 1 это 0,1,2, и т.д
//потом ставим то что должно измениться
for (let i = 0; i < 4; i++) {
    console.log(NewTask[i]);//сдесь мы указываем i
    console.log(NewTask[0]);
    console.log(NewTask[1]); // и т,д когдадошло до 4 цикл завершился
    //пока было справедливым условие i< 4 у нас произашёл выход из цикла
}
//подробнее у нас сдесь меньше 4 соотвественно у нас далее
//с каждой итерацией выбрасывалась число с перва 0
//с циклами осторожно можно не правильно написать условие
//у нас цикл выполняеться до теч пор пока  i<4
//допустим мы укажем пока i < 0 будет бесконечный цикл /зависнет браузер


//ЦИКЛ while()
//что бы цикл заработал нам нужно обьявить переменную
//let i=0;
//while ( i < NewTask.length ) {
//console.log(NewTask[i]);
//i++;
//}

//ЦИКЛ do while почти идентичен while за одним исключением
//сперва это цикл делает, то что указано в его теле, а только потом проверяет условие
//всегда как минимум один раз этот цикл отработает

let i = 0;
do {
    console.log(i);
    i++
} while (i <= 3);  //условие до тех пор пока i<=3 меньше или равно 3
//когда у нас происходила, что переменная становилась равна условию мы выходили из цикла и цикл прерывался
//(i <= 3) сдесь у нас тройка включаеться в нашу итерацию

//УСЛОВНЫЕ КОНСТРУКЦИИ
//просто развилка в нашей программе
//условие что если
//обьявим переменную

let road = "left";
//пишим условие если дорога ровна "left"
//в таком случаи выведится("road to left")
//в противном случаи ("bad")

let turn = (road === "left") ? "road to left" : "bad";
console.log(turn);
// if(road === "left"){
//     console.log("road to left")
// }else if(road === "right"){
//     console.log("road to right")
// }
// else{
//     console.log("bad")
// }
// если используеться одно равно - это присваения значения
// если используеться два равно -это нестрогое сравнение таким образом  у нас 1=="1" еденица приводиться к строке
//к числу тоже таким образом они считаються равными
//если будем использовать строгое сравнение 1==="1" ,
// будет не верно потому как сравниваеться не только значение но и типы а
//а у нас тип число а справа строка соотвественно они не равны
// если сравнить от обратного не равно то пишим восклицательный знак != (не строгое неравество)
// число 1 не равно строке 1 если не строго сравниваем то они равны false
//если строгое на равенство !== то мы получим правду true

// может быть несколько значений
//можем добавить еще условия else if (указываем условие )
//потом пишим что будет происходить при этом условии в консоль лог
// если в переменной будет up (вверх) выполниться шаг else последнее("bad")

//ТЕРНАРНЫЙ ОПЕРАТОР он позволяет сделать короткую запись если развилка использует два пути да ил нет
// создаем переменную turn мы вибираем путь
// пишим условие road === "left" производиться сравнение дорога равна left или нет далее пишим ? вопросительный знак
//после вопросительног знака будет писаться то что у нас вернет правду "road to left"
// и двое точее : после двое точия будет выполнено то что если произайдет сравнения вернет ложь неправду
//выводим в косоль turn и у нас bad сравнение не сработала при первой переменной up
// если поставим вместо up ---left то сравнение сработает

//когда необходимо сравнить два условия
//создаем две переменных
// если task равна "left" ипользуем оперератор и && weather если строгое равно "sun"
// что мы сдесь проверяем что если таск равно лефт и  погода равно сан
//в таком случаи в консоле выведим хеппи в противном случаи анхеппи
// мы выводим хеппи потому что два условия совпадают
//если условие поменть будет анхеппи
// как работает логическое сравнение если у нас и && левая и правая часть должна вернуть истину
// мы можем использовать или ||  в таком случаи либо левая часть должна вернуть правду либо правая часть
// возврат правды левая часть совпадает в таком случаи выполняеться это условие
let task = "left";
let weather = "sun"
if (task === "left" || weather === "rain") {
    console.log("happy")
} else {
    console.log("unhappy")
}

//конструкция SWICH
//создаем переменную и передаем в swich
//пишим кейс первый лефт в коносле бед ту блэк
//сдесь обязательно указываем брейк если не указать то будут выполнены все действия которые укажем
// есть дефолт
// теперь в переменной бед что укажем то и выведит что указали если другое значение то выведит по умолчанию
let bad = "up";

switch (bad) {
    case"black" :
        console.log("bad to black");
        break;
    case"blue" :
        console.log("bad to blue");
        break;
    default:
        console.log("default");
        break;
}

//ОБЬЕКТЫ
// это посути  массива - структура данных в кором можно хранить любые данные
//в формате ключ значение
//обьект можно создать несколькими спосабами
// первый способ обьяляем переменную
let object = new Object();
//второй способ короче
//создали обьект далее в данный обьект добавить данные
let human = {};
//добовляем данные
human.name = "name";
human.age = 25;
//выведим обьект в консоле и унас две записи {name: 'name', age: 25}
console.log(human);
//далее нам надо обраиться к кокомуто значению
console.log(human.age);
//удалить значение с помощью операдара удалить указываем его обьект и значение в косоле останеться  {name: 'name'}
delete human.age;
console.log(human);
//обратиться к значению обьекта но само значение мы должны записать в переменную
let humans = {
    name: "Valya",
    age: 35
};
//далее в переменную новую к добавим возраст
let k = "age";
//далее необходимо обратиться к свойсту ейдж с помощью данной переменной
console.log(humans[k]);

//создаем более сложный обьект
let woman = {
    name: "Valya",
    age: 35,
    weight: 65,
    //иожет быть вложен массив
    favoiriteColor: ["RED", "BLUE"],
    //может быть вложен еще один обьект адресс
    address: {
        city: "Minsk",
        street: "Varvasheny",
        house: 59
    }
};
//выведим наш обьект  в консоль и мы видим адрес,возраст,цвет, массив, имя и вес
console.log(woman);
//удобный способ хранения информации и обработки ее
// если необходимо добраться до города в адрессе
//в косоле пишем
console.log(woman.address.city);

//у обьекта есть несколько методов -перебор свойств с помощью for in
// по сути цикл фо но сдругим синтаксисом
//создаем кей ин
//и указываем в каком обьекте мы будем перебирать эти ключи
//получили все ключи данного обьекта
//все значения данного обьекта
for (let womanKey in woman) {
    console.log(womanKey);//получили все ключи данного обьекта
    console.log(woman[womanKey]);//получаем значение каждого ключа
    console.log(" Key: " + womanKey + " Value: " + woman[womanKey]);//получили всезначения и  ключи данного обьекта
}
//обьекты всегда ссылаються на один и тотже обьект
let user = {
    name: "User"
};
let user2 = user
console.log(user);
console.log(user2);
// мы видим два обьекта одинаковых
//теперь юзер2 изменим имя
//user2.name = "Vasya";
//console.log(user);
//console.log(user2);
//{name: 'User'}name: "Vasya"[[Prototype]]: Object
//main.js:333 {name: 'User'}
//main.js:337 {name: 'Vasya'}name: "Vasya"[[Prototype]]: Object
//main.js:338 {name: 'Vasya'}
//почему изменилась потому что они ссылаються на один и тот же обьект
//изменение в одном сразу делает изменение в другом
//для того чтоб склонировать обьект надо написать отдельно мини функцию
// спомощью цикла

//создаем переменную и обьявляем там пустой обьект
let clone = {};
//далее циклом for in  () в первом обьекте все значения с первого обьекта добовляем в новый обьект клон
//название даем любое
for (const cloneKey in user) {
    clone[cloneKey] = user[cloneKey];
}
// после чего мы можем клон нейм другое имя
clone.name = "Cveta";
console.log(user);
console.log(user2);
console.log(clone);

//ФУНКЦИИ
//функция - это участок кода который необходимо повторять раз за разом
// вынести отдельный кусок кода который при необходимости можно использовать снова
// let c=5,
//     d=6;

let user3 = {
    name: "Vaslu",
    age: 15
}


function func(name, message) {
    // let a = 5;
    //console.log("before return");
    //console.log(a);//вывели ту переменную которую обьявили
    return name + " говорит " + message;// возвращает нам элемент, то есть нашу переменную
    //что бы увидить нам необходимо в консоле увидеть результат выполнения данной функции
    //return (a+b);

}

console.log(func(user3.name, "ПРИВЕТ"));// получили 11 //можно передавать другие переменные
//console.log(func(a,b);// получили 11 //можно передавать другие переменные
//console.log(func(c,d);// получили 11 //можно передавать другие переменные
// для того чтобы запустить функцию нужно указать ее название и круглые скобки
//можем вызвать несколько раз
//func();
//сколько раз вызвали столько произолшо отресовка кода
//внутри функции можем обьявлять переменные
//функция обязательно должна что либо возвращать
//если мы уберем консоль то мы не чего не увидим
//как только остановиться на слове ретерн то все что находиться после функции не выполняеться

//мы можем передавать в нее аргументы a,b название могут быть любые name, message

//функцию можно обьявлять двумя спосабами
function user4(name, message) {
    return name + " говорит " + message;
}

console.log(user4(user3.name, "ПРИВЕТ"));

//второй способ
// // класическое обьявление функции
// function user5 () {
//     console.log("test")
// }
// user5();

// функцию обьявим через переменную let

//users6();// фанкшен экспрешен в контексте какого либо выражения присваевания
//если после того как мы ее вызвали будет ошибка всплытие наверх не проиходит
//let users6 = function user7 () {
//  console.log("test2")
//}


let number = 3;

console.log(number / 0);

//Завершите метод, который принимает логическое значение и возвращает
// "Yes" строку для true или "No" строку для false.

function boolToWord(bool) {
    if (bool === "true" ? "false" : bool) {
        return "Yes";
    } else {
        return "No";
    }


}

boolToWord();
console.log(boolToWord("Yes"));


//const boolToWord = bool => bool ? 'Yes' : 'No';
//function boolToWord( bool ){
//   return bool ? 'Yes':'No';
// }


//Герой на пути к замку, чтобы завершить свою миссию. Однако ему сказали,
// что замок окружен парой могущественных драконов!
// для победы над каждым драконом требуется 2 пули,
// наш герой понятия не имеет, сколько пуль он должен нести..
// Если предположить, что он получит определенное количество пуль
// и двинется вперед, чтобы сразиться с другим определенным
// количеством драконов, выживет ли он?
//
// Верните true, е сли да,falseом  в противнслучае :)

// function hero(bullets, dragons) {
//     let hero=(bullets, dragons);
//     hero= dragons * 2;
//     if ( bullets >= hero) {
//         return true;
//     } else {
//         return false;
//     }
//
//     hero();
// }

// function hero(bullets, dragons){
//     return (bullets / 2 >= dragons) ? true : false;
// }
const hero = (bullets, dragons) => dragons * 2 <= bullets;

console.log(hero(hero(10, 5)));
console.log(hero(hero(4, 5), false));
console.log(hero(hero(100, 40), true));
console.log(hero(hero(1500, 751), false));
console.log(hero(hero(0, 1), false));


//Это довольно просто. Ваша цель - создать функцию, которая удаляет первый и последний символы строки.
// Вам будет предоставлен один параметр - исходная строка.
// Вам не нужно беспокоиться о строках, содержащих менее двух символов.
// function removeChar(str){
//     let newStr= str
//     // return anotherStr = str.substring(1, str.length - 1);// 1способ
//     return newStr = str.slice(1, -1);//2способ
//
//
// };
//
// console.log(removeChar(removeChar('eloquent','loquen')));
// console.log(removeChar(removeChar('country', 'ountr')));
// console.log(removeChar(removeChar('person', 'erso')));
// console.log(removeChar(removeChar('place', 'lac')));
// console.log(removeChar(removeChar('ooopsss', 'oopss')));

//Учитывая строку, вы должны вернуть строку,
// в которой каждый символ (с учетом регистра) повторяется один раз.

// function doubleChar(str) {
//   return doubleChar = (str) => str.split("").map(c => c + c).join(""); 1 способ
//     //return str.replace(/./g, '$&$&'); 2способ
// }
//3 способ
function doubleChar(str) {
    let word = '';
    for (let i = 0; i < str.length; i++) {
        word = word + str[i] + str[i];
    }
    ;
    return word;
};

console.log(doubleChar(doubleChar("abcd", "aabbccdd")));
console.log(doubleChar(doubleChar("Adidas", "AAddiiddaass")));
console.log(doubleChar(doubleChar("1337", "11333377")));
console.log(doubleChar(doubleChar("illuminati", "iilllluummiinnaattii")));
console.log(doubleChar(doubleChar("123456", "112233445566")));
console.log(doubleChar(doubleChar("%^&*(", "%%^^&&**((")));

//Зачем нужна функция React.createContext?
//Контекст позволяет компонентам передавать информацию вглубь без явной передачи реквизитов.
// Вызывает createContext внешние компоненты для создания одного или нескольких контекстов.
//createContext возвращает контекстный объект.
// Компоненты могут считывать контекст, передавая его в useContext():
//По умолчанию значения, которые они получают, будут теми значениями по умолчанию, которые вы указали при создании контекстов.
// Однако само по себе это бесполезно, поскольку значения по умолчанию никогда не меняются.
// Контекст полезен, потому что мы  можете предоставлять другие динамические значения из своих компонентов:
//Теперь Page компонент и любые компоненты внутри него, независимо от того, насколько глубоко, будут “видеть” переданные значения контекста.
// Если переданные значения контекста изменятся, React также повторно отобразит компоненты, считывающие контекст.

//Вы, наверное, знакомы с системой "лайков" на Facebook и других страницах.
// Люди могут "лайкать" записи в блоге, картинки или другие материалы.
// Мы хотим создать текст, который должен отображаться рядом с таким элементом.
// Реализуйте функцию, которая принимает массив, содержащий имена людей,
// которым нравится элемент. Он должен возвращать отображаемый текст, как показано в примерах:
//
// []                                -->  "no one likes this"
// ["Peter"]                         -->  "Peter likes this"
// ["Jacob", "Alex"]                 -->  "Jacob and Alex like this"
// ["Max", "John", "Mark"]           -->  "Max, John and Mark like this"
// ["Alex", "Jacob", "Mark", "Max"]  -->  "Alex, Jacob and 2 others like this"
function likes(names) {
    names = names || []
    switch (names.length) {
        case 0:
            return 'no one likes this'
        case 1:
            return `${names[0]} likes this`
        case 2:
            return `${names[0]} and ${names[1]} like this`
        case 3:
            return `${names[0]}, ${names[1]} and ${names[2]} like this`
        default:
            return `${names[0]}, ${names[1]} and ${names.length - 2} others like this`
    }
}

console.log(likes(likes([], 'no one likes this')));
console.log(likes(likes(['Peter'], 'Peter likes this')));
console.log(likes(likes(['Jacob', 'Alex'], 'Jacob and Alex like this')));
console.log(likes(likes(['Max', 'John', 'Mark'], 'Max, John and Mark like this')));
console.log(likes(likes(['Alex', 'Jacob', 'Mark', 'Max'], 'Alex, Jacob and 2 others like this')));

//Вы пишете код для управления светофорами вашего города.
// Вам нужна функция для обработки каждого изменения с green, на yellow, на red, а затем снова на green.
// Завершите функцию, которая принимает строку в качестве аргумента,
// представляющего текущее состояние источника света, и возвращает строку, представляющую состояние, в которое должен перейти источник света.
// Например, когда ввод green, вывод должен быть yellow.

function updateLight(current) {
    // switch (current) {
    //     case "red": return "green";
    //     case "yellow": return "red";
    //     case "green": return "yellow";
    //     default: throw new  updateLight()
    // }
    //return current === 'yellow' ? 'red' : current === 'green' ? 'yellow' : 'green';
    if (current === 'green') {
        current = 'yellow'
    } else if (current === 'yellow') {
        current = 'red'
    } else if (current === 'red') {
        current = 'green'
    } else {
    }

    return current

}

console.log(updateLight(updateLight("green", "yellow")));
console.log(updateLight(updateLight("yellow", "red")));
console.log(updateLight(updateLight("red", "green")));

//В этом простом упражнении вы создадите программу, которая принимает значение,
// integer  и возвращает список его кратных с точностью до другого значения, limit .
// Если limit число кратно integer, оно также должно быть включено.
// В функцию всегда будут передаваться только положительные целые числа, не состоящие из 0. Предел всегда будет выше базового.
// Например, если переданные параметры являются (2, 6),
// функция должна возвращать [2, 4, 6] значения 2, 4 и 6, кратные от 2 до 6.

// function findMultiples(integer, limit) { //1способ
//     let multiples = [];
//
//     for(let i = integer; i<= limit; i= i+integer){
//         multiples.push(i);
//     }
//     return multiples;
//
//
// }
function findMultiples(int, limit) {
    return Array(Math.floor(limit / int)).fill(1).map((x, i) => int * (i + 1));
}

console.log(findMultiples(5, 25));
console.log(findMultiples(1, 2));
console.log(findMultiples(5, 7));
console.log(findMultiples(4, 27));
console.log(findMultiples(11, 54));

//По прибытии на собеседование вам вручают сплошной синий куб.
// Затем куб окунается в красную краску, покрывающую всю поверхность куба.
// Затем интервьюер продолжает прорезать куб во всех трех измерениях определенное количество раз.
// Ваша функция принимает в качестве параметра количество раз, когда куб был разрезан.
// Вы должны вернуть количество кубиков меньшего размера, созданных срезами, у которых есть хотя бы одна красная грань.
// Чтобы было понятнее, на рисунке ниже показан куб после (слева направо) выполнения 0, 1 и 2 разрезов.

function countSquares(cuts) {

    //return (cuts == 0 ? 1 : cuts == 1 ? 8 : (cuts + 1) ** 3 - (cuts - 1) ** 3) // 1 способ
    // 2способ
    //      if (cuts >= 1) {
    //          return cuts**2 * 3 * 2 + 2
    //      }
    //      else if (cuts == 0) {
    //          return 1
    //      }
    //  }
//3способ
    if (cuts === 0) return 1
    return cuts * 6 * cuts + 2
}


//0=1
//1=8
//2=26=>1
//3=56=>8
//4=98=>27
//5=152=>64

console.log(countSquares(countSquares(5)));
console.log(countSquares(countSquares(16)));
console.log(countSquares(countSquares(23)));

//число, и вы должны сделать его отрицательным.
//
// Примеры
// makeNegative(1);    // return -1
// makeNegative(-5);   // return -5
// makeNegative(0);    // return 0
// makeNegative(0.12); // return -0.12
// Примечания
// Число уже может быть отрицательным, и в этом случае никаких изменений не требуется.
// Ноль (0) не проверяется на наличие какого-либо определенного знака. Отрицательные нули не имеют математического смысла.

function makeNegative(num) {
    //return -Math.abs(num);//1способ
    //return num < 0 ? num : -num;//2способ
}

console.log(makeNegative(makeNegative(42)));

//Создайте функцию, которая будет возвращать оператор приветствия,
// использующий входные данные; ваша программа должна вернуть,
// "Hello, <name> how are you doing today?".

function greetlovefunc(name) {
    return `Hello, ${name} how are you doing today?`
}

console.log(greetlovefunc("Ryan"));
console.log(greetlovefunc("Shingles"));

// Атрибут defer сообщает браузеру, что он должен продолжать
// обрабатывать страницу и загружать скрипт в фоновом режиме,
// а затем запустить этот скрипт, когда DOM дерево будет полностью построено.
//Скрипты с defer никогда не блокируют страницу.
// Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.

//Атрибут async означает, что скрипт абсолютно независим:
// Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
// Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
// DOMContentLoaded может произойти как до асинхронного скрипта
// (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
// …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
// Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.


//Тимми и Сара думают, что они влюблены, но в районе,
// где они живут, они узнают об этом, только сорвав по цветку каждый.
// Если у одного из цветов четное количество лепестков, а у другого нечетное, это означает, что они влюблены.
// Напишите функцию, которая будет принимать количество лепестков каждого
// цветка и возвращать true, если они влюблены, и false, если нет.
//1способ
// function lovefunc(flower1, flower2){
//     return  lovefunc = (flower1, flower2) => (flower1 + flower2) % 2 !== 0;
// }

function lovefunc(flower1, flower2) {
    const num = flower1 + flower2
    if (num % 2 == 0) {
        return false;
    } else {
        return true;
    }

}

console.log(lovefunc(lovefunc(1, 4)))
console.log(lovefunc(lovefunc(2, 2)))
console.log(lovefunc(lovefunc(0, 1)))
console.log(lovefunc(lovefunc(0, 0)))

// x % 2 == 0 - четное число
// x % 2 == 1 - нечётное число
// Аналогично проверяется чётность любого числа с любым (кроме 0):
// x % y == 0 - x кратно y

//Нам нужна функция, которая может преобразовывать число (integer) в строку.
// Какие способы достижения этого вы знаете?
//array.join(" привет "))
//Примеры (ввод -> вывод):
// 123  --> "123"
// 999  --> "999"
// -100 --> "-100"
function numberToString(num) {
    return num.toString();
}

console.log(numberToString(numberToString(67), '67'));

//Напишите функцию для преобразования имени в инициалы.
// Это ката состоит строго из двух слов с одним пробелом между ними.
// Выходные данные должны состоять из двух заглавных букв с разделяющей их точкой.
// Это должно выглядеть примерно так:
// Sam Harris => S.H
// patrick feeney => P.F
//replace() Метод возвращает новую строку с одним, некоторыми или всеми совпадениями a,
// pattern замененными на a replacement. pattern Может быть строкой или a RegExp,
// а replacement может быть строкой или функцией, вызываемой для каждого соответствия.
// Если pattern является строкой, будет заменено только первое вхождение.
// Исходная строка остается неизменной.
//Пример:
// Ввод: "john doe"
// Разделите их: ["john", "doe"]
// Берем 1-й символ: "j" // 1-е слово
// Сделать его заглавным: "J" // 1-е слово
// Берем 1-й символ: "d" // 2-е слово
// Сделать его заглавным: "D" // 2-е слово
// Соедините их точкой: "J.D"
// Вывод: "J.D"
function abbrevName(name) {
    return (
        name.split(" ").map((n) => n[0].toUpperCase()).join(".")
    );
}

console.log(abbrevName(abbrevName("Sam Harris")));//S.H
console.log(abbrevName(abbrevName("Patrick Feenan")));
console.log(abbrevName(abbrevName("Evan Cole")));
console.log(abbrevName(abbrevName("P Favuzzi")));
console.log(abbrevName(abbrevName("David Mendieta")));

//Создайте функцию, которая проверяет, делится ли число n на два числа x И y.
// Все входные данные являются положительными, ненулевыми числами.

//Examples:
//1) n =   3, x = 1, y = 3 =>  true because   3 is divisible by 1 and 3
//2) n =  12, x = 2, y = 6 =>  true because  12 is divisible by 2 and 6
//3) n = 100, x = 5, y = 3 => false because 100 is not divisible by 3
//4) n =  12, x = 7, y = 5 => false because  12 is neither divisible by 7 nor 5
function isDivisible(n, x, y) {
    // if(n % x == 0 && n % y ==0) 1 способ
    //     return true;
    //     else
    //  return false;

    return (n % x === 0 && n % y === 0) ? true : false; // 2 способ
}

console.log(isDivisible(isDivisible(3, 3, 4, false)));
console.log(isDivisible(isDivisible(12, 3, 4, true)));
console.log(isDivisible(isDivisible(8, 3, 4, false)));
console.log(isDivisible(isDivisible(48, 3, 4, true)));


//Вы получаете массив чисел, возвращаете сумму всех положительных.
// Пример [1,-4,7,12] => 1 + 7 + 12 = 20
// Примечание: если нечего суммировать, сумма по умолчанию равна 0.

function positiveSum(arr) {
    let result = 0
    for (i=0;i<arr.length;i++){
        if(arr[i] > 0){
            result += arr[i]
        }
    }
    return result
}
//0
console.log(positiveSum(positiveSum([1, 2, 3, 4, 5])));
console.log(positiveSum(positiveSum([1, -2, 3, 4, 5])));
console.log(positiveSum(positiveSum([])));
console.log(positiveSum(positiveSum([-1, -2, -3, -4, -5])));
console.log(positiveSum(positiveSum([-1, 2, 3, 4, -5])));


